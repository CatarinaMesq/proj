Para Fazer

Ao comentar Ã© permitido criar "posts" em branco sem conteudo.

To prevent empty comments, you can add a validation step in your post route that checks if the comment content is
empty before creating a new comment in the database.

Here's an updated version of the post route that includes this validation step:

@app.route('/post', methods=['GET', 'POST'])
def post():
    form = LoginForm()
    c.execute("""
        SELECT * FROM posts
        ORDER BY posts.created_at DESC
    """)
    posts = c.fetchall()

    c.execute("""
        SELECT * FROM comments
        ORDER BY comments.timestamp DESC
    """)
    comments = c.fetchall()

    if request.method == 'POST':
        # Get the uploaded image
        image = request.files['image']

        # Check if the file is an image
        if not image.filename.endswith(('.jpg', '.jpeg', '.png', '.gif')):
            flash('Invalid file type. Please upload a JPG, JPEG, PNG, or GIF file.', 'error')
            return redirect(request.url)

        # Save the image to a temporary file
        filename = secure_filename(image.filename)
        image_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        image.save(image_path)

        # Get the post content
        content = request.form['content']

        # Get the user ID of the logged in user
        user_id = None
        if 'username' in session:
            username = session['username']
            c.execute("SELECT id FROM users WHERE username = ?", (username,))
            result = c.fetchone()
            if result:
                user_id = result[0]

        # Create a new comment if the content is not empty
        if content.strip() != '':
            c.execute("INSERT INTO comments (user_id, post_id, content) VALUES (?, ?, ?)",
                      (user_id, request.form['post_id'], content))
            conn.commit()

    post_list = []
    for post in posts:
        if isinstance(post[2], bytes):
            encoded_string = base64.b64encode(post[2]).decode("utf-8")
        else:
            encoded_string = base64.b64encode(post[2].encode()).decode("utf-8")
        post_dict = {
            'id': post[0],
            'user_id': post[1],
            'picture': f"data:image/png;base64,{encoded_string}",
            'content': post[3],
            'created_at': post[4]
        }
        post_list.append(post_dict)

    return render_template('post.html', posts=post_list, form=form, comments=comments)

To handle the error when a user inputs a blank post, you can implement some form of validation in your code. Here's an example of how you can do it:

In the function that handles the submission of the comment, add a check to see if the comment is blank. For example:


def submit_comment(comment):
    if comment.strip() == '':
        raise ValueError('Comment cannot be empty')
    else:
        # Add the comment to the database


If the comment is blank, raise a ValueError with an appropriate error message. This will prevent the comment from being added to the database.
In the code that calls the submit_comment function, catch the ValueError and handle it appropriately. For example, you can display an error
message to the user asking them to enter a valid comment:


try:
    submit_comment(user_comment)
except ValueError as e:
    # Display an error message to the user
    print(e)

By adding this error handling code, your app will now prevent users from submitting empty comments and provide feedback to the user when they attempt to do so.

If your HTML includes any elements that are related to the comment functionality,
such as a comment form or a button to submit comments, then you may need to make adjustments to the HTML as well.

<input type="text" id="comment" name="comment" required>


